---
title: "The irlba package"
output:
html_document:
    theme: cerulean
---
<style>
body{ font-size: 15pt; }
blockquote{ font-size: 14pt; }
pre{ font-size: 14pt; }
h1{ font-size: 28pt; }
h2,h3,h4,h5,h6{ font-size: 24pt; }
.main-container{ max-width: 85%; }
</style>

The augmented implicitly restarted Lanczos bidiagonalization algorithm (IRLBA)
finds a few approximate largest singular values and corresponding singular
vectors of a sparse or dense matrix using a method of Baglama and Reichel.

> J. Baglama and L. Reichel, SIAM J. Sci. Comput. (2005). (http://www.math.uri.edu/~jbaglama/papers/paper14.pdf)

It is a fast and memory-efficient way to compute a partial SVD, principal
components, and some specialized partial eigenvalue decompositions.  I
introduced Baglama and Reichel's irlba algorithm to the R world in a talk at
the useR! conference in Dortmund way back in 2008.

# What's new in version 2.2.1 (May, 2017)

- IRLBA-based functions include stronger convergence criteria and a new argument called svtol for that. The new approach helps guarantee more accurate solutions for some difficult problems. The tradeoff is that the default behavior is a little slower than before because at least two Lanczos iterations are always run. The new convergence behavior can be disabled with svtol=Inf.
- The new package version includes a new function, svdr()--another state of the art truncated SVD method based on the randomized SVD algorithm of Gunnar Martinsson and others. Both irlba() and svdr() work well. Svdr uses a block method and may exhibit better convergence in problems where the largest singular values are clustered. See the documentation and examples in the package. (Block versions of irlba exists, but are not yet implemented by this R package--something coming in the future.)
- We re-introduced a solver for estimating the smallest singular values of a matrix and associated singular vector spaces. The solver is based on the oringial Harmonic Ritz vector augmentation method of Baglama and Reichel.  Beware that this method is somewhat experimental and may fail to converge, or may converge poorly, to estimated singular values for very ill-conditioned matrices. Along with block methods for irlba, this is an active area of work--feel free to contribute!
- The mult() argument is deprecated and will be removed in a future version. Instead, we now recommend simply defining a custom class with a custom multiplcation operator. The example below illustrates the old and new approaches.

```{r, eval=FALSE}
library(irlba)
set.seed(1)
A <- matrix(rnorm(100), 10)
# Define a custom matrix multiplication function that scales the columns of A
# to have unit norm (cf the scale option).

# ------------------ the new way ------------------------------------------
# Simply using an S4 class
setClass("scaled_matrix", contains="matrix", slots=c(scale="numeric"))
setMethod("%*%", signature(x="scaled_matrix", y="numeric"), function(x ,y) x@.Data %*% (y / x@scale))
setMethod("%*%", signature(x="numeric", y="scaled_matrix"), function(x ,y) (x %*% y@.Data) / y@scale)
a <- new("scaled_matrix", A, scale=col_scale)

irlba(a, 3)$d
## [1] 1.820227 1.622988 1.067185


# ------------------ the old way ------------------------------------------
col_scale <- sqrt(apply(A, 2, crossprod))
mult <- function(x, y)
        {
          # check if x is a  vector
          if (is.vector(x))
          {
            return((x %*% y) / col_scale)
          }
          # else x is the matrix
          x %*% (y / col_scale)
        }
irlba(A, 3, mult=mult)$d
## [1] 1.820227 1.622988 1.067185


# ------------------ compare ----------------------------------------------
irlba(A, 3, scale=col_scale)$d
## [1] 1.820227 1.622988 1.067185

# Or,
svd(sweep(A, 2, col_scale, FUN=`/`))$d[1:3]
## [1] 1.820227 1.622988 1.067185
```


# Vignettes

The package vignette (PDF): https://cran.r-project.org/web/packages/irlba/irlba.pdf.

This example uses a special one-sided basis option and a custom matrix product
to compute the top three principal components of the entire 1000 Genomes
Project variant data set (whole genome variants for 2,504 people):
http://bwlewis.github.io/1000_genomes_examples/PCA_whole_genome.html The
example optionally works in parallel and finishes in only 8 minutes on a 4 node
Linux cluster.

https://bwlewis.github.io/irlba/comparison.html compares the irlba package
with the RSpectra package, a high-quality eigenvalue solver for R.

## Other applications

The newe `tcor` algorithm (http://arxiv.org/abs/1512.07246) and R package
(https://github.com/bwlewis/tcor -- not yet on CRAN) use irlba to compute
thresholded correlation matrices very quickly. This example computes the most
highly correlated gene expressions from the Cancer Genome Atlas RNASeq gene
expression data for breast cancer:
https://github.com/bwlewis/tcor/blob/master/vignettes/brca.Rmd.

Many more applications will appear here soon, check back!
